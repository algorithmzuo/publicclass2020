package class129;

import java.util.Arrays;

// 来自小红书
// 实验室需要配制一种溶液，现在研究员面前有n种该物质的溶液，
// 每一种有无限多瓶，第i种的溶液体积为v[i]，里面含有w[i]单位的该物质
// 研究员每次可以选择一瓶溶液，
// 将其倒入另外一瓶（假设瓶子的容量无限），即可以看作将两个瓶子内的溶液合并
// 此时合并的溶液体积和物质含量都等于之前两个瓶子内的之和。
// 特别地，如果瓶子A与B的溶液体积相同，那么A与B合并之后
// 该物质的含量会产生化学反应，使得该物质含量增加x单位
// 研究员的任务是配制溶液体积恰好等于c的，且尽量浓的溶液(即物质含量尽量多）
// 研究员想要知道物质含量最多是多少
// 对于所有数据，1 <= n, v[i], w[i], x, c <= 1000
public class Code02_ChemicalProblem {

	public static int maxValue(int[] v, int[] w, int x, int c) {
		int n = v.length;
		// dp[0] ?
		// dp[1] ?
		// dp[10] ?
		// dp[c] ?
		int[] dp = new int[c + 1];
		// dp[0] = -1
		// dp[1] = -1
		// ....
		// dp[i] = -1，当前i体积的最好含量，没有解!
		Arrays.fill(dp, -1);
		// 枚举所有规格
		// 3  4
		// 5  10
		// 3  8
		// dp[3] = 8
		// 对于所有dp[i]，先把可能性1（不分裂的时候）得到的最好答案，填入！
		for (int i = 0; i < n; i++) {
			// 3   8
			if (v[i] <= c) {
				// dp[3] = Maht.max(dp[3], w[i]);
				dp[v[i]] = Math.max(dp[v[i]], w[i]);
			}
		}
		// 10^8，运行能通过，运行时间不超过1s
		// 1000 * 1000 = 10^6 考试时候，肯定能通过的！
		for (int i = 1; i <= c; i++) {
			// i = 10
			// 1 + 9 -> 
			// 2 + 8 -> 
			// 4 + 6 -> 
			// 5 + 5 -> 还要额外加x!
			for (int j = 1; j <= i / 2; j++) {
				// dp[i] = dp[j] + dp[i-j]
				// dp[10]  = dp[3] + dp[7]
				if (dp[j] != -1 && dp[i - j] != -1) {
					dp[i] = Math.max(dp[i], dp[j] + dp[i - j] + (j == i - j ? x : 0));
				}
			}
		}
		return dp[c];
	}

	public static void main(String[] args) {
		// 都是一种溶液
		// 规格 : 
		// 0号规格 : 体积5，含量2
		// 1号规格 : 体积3，含量4
		// 2号规格 : 体积4，含量1
		// 
		// (体积5，含量2) + (体积3，含量4) = (体积8，含量6)
		// 特别的:
		// (体积5，含量4) + (体积5，含量3) = (体积10，含量4 + 3 + x)
		// (体积5，含量2) + (体积5，含量2) = (体积10，含量2 + 2 + x)
		// x一个固定的整数，输入参数
		// 体积一定要达到c的时候，得到的最多含量是多少？
		int[] v = { 5, 3, 4 };
		int[] w = { 2, 4, 1 };
		int x = 4;
		int c = 16;
		// (体积3，含量4) + (体积3，含量4) -> (体积6, 含量12)额外+x
		// (体积3，含量4) + (体积3，含量4) -> (体积6, 含量12)额外+x
		// (体积6, 含量12) + (体积6, 含量12) -> (体积12，含量28)额外+x
		// (体积12，含量28) + (体积4，含量1) -> (体积16，含量29)没有额外+x
		System.out.println(maxValue(v, w, x, c));
	}

}
